// SPDX-License-Identifier: MIT
// Copyright (c) 2025 Matthias Bilger <matthias@bilger.info>

mod app;
mod config;
mod ui;

use anyhow::{Context, Result};
use app::{AppState, LogLevel};
use clap::Parser;
use config::{Config, TeamsStateType};
use mutenix_hid::{ConnectionState as DeviceConnectionState, HidDevice, HidInputMessage, SetLed, Status};
use std::collections::HashMap;
use std::path::PathBuf;
use std::sync::Arc;
use teams_api::{
    ClientMessage, ConnectionState as TeamsConnectionState, Identifier, MeetingState, ServerMessage,
    TeamsState, TeamsWebSocketClient,
};
use tokio::fs;
use tokio::sync::RwLock;
use ui::Ui;

const DEFAULT_CONFIG_PATH: &str = "mutenix.yaml";
const TOKEN_FILE: &str = ".mutenix_token";
const TEAMS_WS_URI: &str = "ws://localhost:8124";

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Path to the configuration file
    #[arg(short, long, default_value = DEFAULT_CONFIG_PATH)]
    config: PathBuf,

    /// Teams WebSocket URI
    #[arg(short, long, default_value = TEAMS_WS_URI)]
    teams_uri: String,

    /// Token file path
    #[arg(short = 'T', long, default_value = TOKEN_FILE)]
    token_file: PathBuf,

    /// Disable terminal UI (run in background mode)
    #[arg(long)]
    no_ui: bool,
}

struct MutenixCli {
    config: Config,
    device: Arc<HidDevice>,
    teams_client: Arc<TeamsWebSocketClient>,
    teams_state: TeamsState,
    token_file: PathBuf,
    saved_token: Arc<RwLock<String>>,
    button_press_times: Arc<RwLock<HashMap<u8, std::time::Instant>>>,
    app_state: AppState,
}

impl MutenixCli {
    async fn new(args: Args) -> Result<Self> {
        // Load configuration
        let config = Config::from_file(&args.config)
            .with_context(|| format!("Failed to load config from {:?}", args.config))?;

        // Create app state
        let app_state = AppState::new(env!("CARGO_PKG_VERSION").to_string());

        // Load saved token
        let saved_token = Arc::new(RwLock::new(load_token(&args.token_file).await));

        // Create HID device
        let device_info = config.get_device_info();
        let device = Arc::new(HidDevice::new(device_info));

        // Create Teams state and client
        let teams_state = TeamsState::new();
        let identifier = Identifier::new("Mutenix", "CLI", "mutenix-cli", env!("CARGO_PKG_VERSION"))
            .with_token(saved_token.read().await.clone());

        let teams_client = Arc::new(TeamsWebSocketClient::new(
            teams_state.clone(),
            args.teams_uri,
            identifier,
        ));

        Ok(Self {
            config,
            device,
            teams_client,
            teams_state,
            token_file: args.token_file,
            saved_token,
            button_press_times: Arc::new(RwLock::new(HashMap::new())),
            app_state,
        })
    }

    async fn run(&self) -> Result<()> {
        self.app_state
            .add_device_log(LogLevel::Info, "Starting Mutenix CLI")
            .await;

        // Setup device callbacks
        self.setup_device_callbacks().await;

        // Setup Teams callbacks
        self.setup_teams_callbacks().await;

        // Start device status monitor
        self.start_device_status_monitor();

        // Start Teams status monitor
        self.start_teams_status_monitor();

        // Start Teams client
        let teams_client = self.teams_client.clone();
        tokio::spawn(async move {
            if let Err(e) = teams_client.process().await {
                eprintln!("Teams client error: {}", e);
            }
        });

        // Wait a bit for Teams to connect
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;

        // Query initial state
        self.app_state
            .add_teams_log(LogLevel::Info, "Querying initial Teams state")
            .await;
        if let Err(e) = self.teams_client.send_message(ClientMessage::action(
            teams_api::MeetingAction::QueryMeetingState,
        )) {
            self.app_state
                .add_teams_log(LogLevel::Error, format!("Failed to query state: {}", e))
                .await;
        }

        // Start LED update task
        self.start_led_update_task();

        // Start device processing in background
        let device = self.device.clone();
        let app_state = self.app_state.clone();
        tokio::spawn(async move {
            if let Err(e) = device.process().await {
                app_state
                    .add_device_log(LogLevel::Error, format!("Device error: {}", e))
                    .await;
            }
        });

        Ok(())
    }

    async fn setup_device_callbacks(&self) {
        let config = self.config.clone();
        let teams_client = self.teams_client.clone();
        let button_times = self.button_press_times.clone();
        let app_state = self.app_state.clone();

        self.device
            .register_callback(move |data| {
                // Parse incoming message
                if let Ok(status) = Status::from_buffer(data) {
                    let button_id = status.button();
                    let is_pressed = status.pressed();

                    let config = config.clone();
                    let teams_client = teams_client.clone();
                    let button_times = button_times.clone();
                    let app_state = app_state.clone();

                    tokio::spawn(async move {
                        app_state
                            .add_device_log(
                                LogLevel::Info,
                                format!(
                                    "Button {} {}",
                                    button_id,
                                    if is_pressed { "pressed" } else { "released" }
                                ),
                            )
                            .await;

                        if is_pressed {
                            // Record press time
                            button_times
                                .write()
                                .await
                                .insert(button_id, std::time::Instant::now());
                        } else {
                            // Handle release - determine if it's a long press
                            let press_duration =
                                if let Some(press_time) = button_times.write().await.remove(&button_id)
                                {
                                    press_time.elapsed()
                                } else {
                                    std::time::Duration::from_millis(0)
                                };

                            let is_long_press = press_duration.as_millis() > 500;

                            // Get the appropriate action
                            let button_action = if is_long_press {
                                config.find_longpress_action(button_id)
                            } else {
                                config.find_button_action(button_id)
                            };

                            if let Some(action_config) = button_action {
                                app_state
                                    .add_device_log(
                                        LogLevel::Info,
                                        format!(
                                            "Executing {} for button {}",
                                            if is_long_press {
                                                "long-press action"
                                            } else {
                                                "action"
                                            },
                                            button_id
                                        ),
                                    )
                                    .await;

                                for action in &action_config.actions {
                                    // Check if we should activate Teams window
                                    if action.should_activate_teams() {
                                        app_state
                                            .add_device_log(LogLevel::Info, "Activating Teams window")
                                            .await;
                                    }

                                    // Execute Teams meeting action
                                    if let Some(meeting_action) = action.to_teams_action() {
                                        app_state
                                            .add_teams_log(
                                                LogLevel::Info,
                                                format!("Sending action: {:?}", meeting_action),
                                            )
                                            .await;
                                        if let Err(e) =
                                            teams_client.send_message(ClientMessage::action(meeting_action))
                                        {
                                            app_state
                                                .add_teams_log(
                                                    LogLevel::Error,
                                                    format!("Failed to send action: {}", e),
                                                )
                                                .await;
                                        }
                                    }

                                    // Execute Teams reaction
                                    if let Some(reaction) = action.to_teams_reaction() {
                                        app_state
                                            .add_teams_log(
                                                LogLevel::Info,
                                                format!("Sending reaction: {:?}", reaction),
                                            )
                                            .await;
                                        if let Err(e) =
                                            teams_client.send_message(ClientMessage::reaction(reaction))
                                        {
                                            app_state
                                                .add_teams_log(
                                                    LogLevel::Error,
                                                    format!("Failed to send reaction: {}", e),
                                                )
                                                .await;
                                        }
                                    }
                                }
                            } else {
                                app_state
                                    .add_device_log(
                                        LogLevel::Warn,
                                        format!("No action configured for button {}", button_id),
                                    )
                                    .await;
                            }
                        }
                    });
                }
            })
            .await;
    }

    async fn setup_teams_callbacks(&self) {
        let saved_token = self.saved_token.clone();
        let token_file = self.token_file.clone();
        let app_state = self.app_state.clone();

        self.teams_client
            .register_callback(move |message: ServerMessage| {
                let app_state = app_state.clone();

                // Handle token refresh
                if let Some(new_token) = &message.token_refresh {
                    let token_to_save = new_token.clone();
                    let saved_token = saved_token.clone();
                    let token_file = token_file.clone();
                    let app_state_clone = app_state.clone();

                    tokio::spawn(async move {
                        app_state_clone
                            .add_teams_log(LogLevel::Info, "Received new authentication token")
                            .await;
                        *saved_token.write().await = token_to_save.clone();
                        if let Err(e) = save_token(&token_file, &token_to_save).await {
                            app_state_clone
                                .add_teams_log(LogLevel::Error, format!("Failed to save token: {}", e))
                                .await;
                        } else {
                            app_state_clone
                                .add_teams_log(LogLevel::Info, "Token saved successfully")
                                .await;
                        }
                    });
                }

                // Log meeting state updates
                if let Some(update) = &message.meeting_update {
                    if let Some(state) = &update.meeting_state {
                        let app_state_clone = app_state.clone();
                        tokio::spawn(async move {
                            app_state_clone
                                .add_teams_log(
                                    LogLevel::Info,
                                    format!(
                                        "State update: muted={}, video={}, meeting={}",
                                        state.is_muted, state.is_video_on, state.is_in_meeting
                                    ),
                                )
                                .await;
                        });
                    }
                }
            })
            .await;
    }

    fn start_device_status_monitor(&self) {
        let device = self.device.clone();
        let app_state = self.app_state.clone();

        tokio::spawn(async move {
            loop {
                tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;

                let hw_state = device.state().await;

                app_state
                    .update_device_status(|status| {
                        status.connected = hw_state.connection_status == DeviceConnectionState::Connected;
                        status.manufacturer = hw_state.manufacturer.clone();
                        status.product = hw_state.product.clone();
                        status.serial_number = hw_state.serial_number.clone();
                    })
                    .await;
            }
        });
    }

    fn start_teams_status_monitor(&self) {
        let teams_state = self.teams_state.clone();
        let app_state = self.app_state.clone();

        tokio::spawn(async move {
            loop {
                tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;

                let connection_status = teams_state.connection_status().await;
                let server_message = teams_state.state().await;
                let meeting_state = server_message
                    .meeting_update
                    .as_ref()
                    .and_then(|u| u.meeting_state.as_ref());

                app_state
                    .update_teams_status(|status| {
                        status.connected = connection_status == TeamsConnectionState::Connected;
                        if let Some(state) = meeting_state {
                            status.in_meeting = state.is_in_meeting;
                            status.is_muted = state.is_muted;
                            status.is_video_on = state.is_video_on;
                            status.is_hand_raised = state.is_hand_raised;
                            status.is_recording = state.is_recording_on;
                        }
                    })
                    .await;
            }
        });
    }

    fn start_led_update_task(&self) {
        let device = self.device.clone();
        let teams_state = self.teams_state.clone();
        let config = self.config.clone();
        let app_state = self.app_state.clone();

        tokio::spawn(async move {
            loop {
                tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;

                // Get current Teams meeting state
                let server_message = teams_state.state().await;
                let meeting_state = server_message
                    .meeting_update
                    .as_ref()
                    .and_then(|u| u.meeting_state.as_ref());

                // Update LEDs based on configuration
                for led_config in &config.led_status {
                    if led_config.off {
                        // LED is disabled
                        continue;
                    }

                    if let Some(teams_config) = &led_config.teams_state {
                        let is_state_active = meeting_state
                            .map(|state| Self::check_teams_state(state, &teams_config.teams_state))
                            .unwrap_or(false);

                        let color = if is_state_active {
                            teams_config.color_on.to_led_color()
                        } else {
                            teams_config.color_off.to_led_color()
                        };

                        if let Err(e) = device
                            .send_command(SetLed::new(led_config.button_id, color))
                            .await
                        {
                            app_state
                                .add_device_log(
                                    LogLevel::Error,
                                    format!("Failed to set LED {}: {}", led_config.button_id, e),
                                )
                                .await;
                        }
                    }
                }
            }
        });
    }

    fn check_teams_state(state: &MeetingState, state_type: &TeamsStateType) -> bool {
        match state_type {
            TeamsStateType::IsMuted => state.is_muted,
            TeamsStateType::IsHandRaised => state.is_hand_raised,
            TeamsStateType::IsVideoOn => state.is_video_on,
            TeamsStateType::IsInMeeting => state.is_in_meeting,
            TeamsStateType::IsRecordingOn => state.is_recording_on,
            TeamsStateType::IsBackgroundBlurred => state.is_background_blurred,
            TeamsStateType::IsSharing => state.is_sharing,
            TeamsStateType::HasUnreadMessages => state.has_unread_messages,
        }
    }
}

async fn load_token(path: &PathBuf) -> String {
    match fs::read_to_string(path).await {
        Ok(token) => token.trim().to_string(),
        Err(_) => String::new(),
    }
}

async fn save_token(path: &PathBuf, token: &str) -> Result<()> {
    fs::write(path, token)
        .await
        .with_context(|| format!("Failed to save token to {:?}", path))?;
    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    let args = Args::parse();
    let no_ui = args.no_ui;

    // Create and initialize CLI
    let cli = MutenixCli::new(args).await?;
    cli.run().await?;

    if no_ui {
        // Run without UI (background mode)
        println!("Mutenix CLI v{} running in background mode", env!("CARGO_PKG_VERSION"));
        println!("Press Ctrl+C to exit");

        // Wait indefinitely
        tokio::signal::ctrl_c().await?;
    } else {
        // Run with TUI
        let mut ui = Ui::new()?;
        let app_state = cli.app_state.clone();

        // Run UI (blocks until 'q' is pressed)
        let result = ui.run(app_state).await;

        // Cleanup terminal
        ui.cleanup()?;

        result?;
    }

    Ok(())
}


struct MutenixCli {
    config: Config,
    device: Arc<HidDevice>,
    teams_client: Arc<TeamsWebSocketClient>,
    teams_state: TeamsState,
    token_file: PathBuf,
    saved_token: Arc<RwLock<String>>,
    button_press_times: Arc<RwLock<HashMap<u8, std::time::Instant>>>,
    app_state: AppState,
}

impl MutenixCli {
    async fn new(args: Args) -> Result<Self> {
        // Load configuration
        let config = Config::from_file(&args.config)
            .with_context(|| format!("Failed to load config from {:?}", args.config))?;

        // Create app state
        let app_state = AppState::new(env!("CARGO_PKG_VERSION").to_string());

        // Load saved token
        let saved_token = Arc::new(RwLock::new(load_token(&args.token_file).await));

        // Create HID device
        let device_info = config.get_device_info();
        let device = Arc::new(HidDevice::new(device_info));

        // Create Teams state and client
        let teams_state = TeamsState::new();
        let identifier = Identifier::new("Mutenix", "CLI", "mutenix-cli", env!("CARGO_PKG_VERSION"))
            .with_token(saved_token.read().await.clone());

        let teams_client = Arc::new(TeamsWebSocketClient::new(
            teams_state.clone(),
            args.teams_uri,
            identifier,
        ));

        Ok(Self {
            config,
            device,
            teams_client,
            teams_state,
            token_file: args.token_file,
            saved_token,
            button_press_times: Arc::new(RwLock::new(HashMap::new())),
            app_state,
        })
    }

    async fn run(&self) -> Result<()> {
        self.app_state
            .add_device_log(LogLevel::Info, "Starting Mutenix CLI")
            .await;

        // Setup device callbacks
        self.setup_device_callbacks().await;

        // Setup Teams callbacks
        self.setup_teams_callbacks().await;

        // Start device status monitor
        self.start_device_status_monitor();

        // Start Teams status monitor
        self.start_teams_status_monitor();

        // Start Teams client
        let teams_client = self.teams_client.clone();
        tokio::spawn(async move {
            if let Err(e) = teams_client.process().await {
                eprintln!("Teams client error: {}", e);
            }
        });

        // Wait a bit for Teams to connect
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;

        // Query initial state
        self.app_state
            .add_teams_log(LogLevel::Info, "Querying initial Teams state")
            .await;
        if let Err(e) = self.teams_client.send_message(ClientMessage::action(
            teams_api::MeetingAction::QueryMeetingState,
        )) {
            self.app_state
                .add_teams_log(LogLevel::Error, format!("Failed to query state: {}", e))
                .await;
        }

        // Start LED update task
        self.start_led_update_task();

        // Start device processing in background
        let device = self.device.clone();
        let app_state = self.app_state.clone();
        tokio::spawn(async move {
            if let Err(e) = device.process().await {
                app_state
                    .add_device_log(LogLevel::Error, format!("Device error: {}", e))
                    .await;
            }
        });

        Ok(())
    }

    async fn setup_device_callbacks(&self) {
        let config = self.config.clone();
        let teams_client = self.teams_client.clone();
        let button_times = self.button_press_times.clone();

        self.device
            .register_callback(move |data| {
                // Parse incoming message
                if let Ok(status) = Status::from_buffer(data) {
                    let button_id = status.button();
                    let is_pressed = status.pressed();

                    info!("Button {} {}", button_id, if is_pressed { "pressed" } else { "released" });

                    // Handle button press/release
                    let config = config.clone();
                    let teams_client = teams_client.clone();
                    let button_times = button_times.clone();

                    tokio::spawn(async move {
                        if is_pressed {
                            // Record press time
                            button_times.write().await.insert(button_id, std::time::Instant::now());
                        } else {
                            // Handle release - determine if it's a long press
                            let press_duration = if let Some(press_time) = button_times.write().await.remove(&button_id) {
                                press_time.elapsed()
                            } else {
                                std::time::Duration::from_millis(0)
                            };

                            let is_long_press = press_duration.as_millis() > 500;

                            // Get the appropriate action
                            let button_action = if is_long_press {
                                config.find_longpress_action(button_id)
                            } else {
                                config.find_button_action(button_id)
                            };

                            if let Some(action_config) = button_action {
                                info!("Executing {} for button {}", 
                                    if is_long_press { "long-press action" } else { "action" }, 
                                    button_id);

                                for action in &action_config.actions {
                                    // Check if we should activate Teams window
                                    if action.should_activate_teams() {
                                        info!("Activating Teams window");
                                        // TODO: Implement Teams window activation via system API
                                    }

                                    // Execute Teams meeting action
                                    if let Some(meeting_action) = action.to_teams_action() {
                                        info!("Sending Teams action: {:?}", meeting_action);
                                        if let Err(e) = teams_client.send_message(ClientMessage::action(meeting_action)) {
                                            error!("Failed to send Teams action: {}", e);
                                        }
                                    }

                                    // Execute Teams reaction
                                    if let Some(reaction) = action.to_teams_reaction() {
                                        info!("Sending Teams reaction: {:?}", reaction);
                                        if let Err(e) = teams_client.send_message(ClientMessage::reaction(reaction)) {
                                            error!("Failed to send Teams reaction: {}", e);
                                        }
                                    }
                                }
                            } else {
                                warn!("No action configured for button {}", button_id);
                            }
                        }
                    });
                }
            })
            .await;
    }

    async fn setup_teams_callbacks(&self) {
        let saved_token = self.saved_token.clone();
        let token_file = self.token_file.clone();

        self.teams_client
            .register_callback(move |message: ServerMessage| {
                // Handle token refresh
                if let Some(new_token) = &message.token_refresh {
                    info!("Received new authentication token");
                    let token_to_save = new_token.clone();
                    let saved_token = saved_token.clone();
                    let token_file = token_file.clone();

                    tokio::spawn(async move {
                        *saved_token.write().await = token_to_save.clone();
                        if let Err(e) = save_token(&token_file, &token_to_save).await {
                            error!("Failed to save token: {}", e);
                        } else {
                            info!("Token saved successfully");
                        }
                    });
                }

                // Log meeting state updates
                if let Some(update) = &message.meeting_update {
                    if let Some(state) = &update.meeting_state {
                        info!("Meeting state updated: muted={}, video={}, in_meeting={}", 
                            state.is_muted, state.is_video_on, state.is_in_meeting);
                    }
                }
            })
            .await;
    }

    fn start_led_update_task(&self) {
        let device = self.device.clone();
        let teams_state = self.teams_state.clone();
        let config = self.config.clone();

        tokio::spawn(async move {
            loop {
                tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;

                // Get current Teams meeting state
                let server_message = teams_state.state().await;
                let meeting_state = server_message
                    .meeting_update
                    .as_ref()
                    .and_then(|u| u.meeting_state.as_ref());

                // Update LEDs based on configuration
                for led_config in &config.led_status {
                    if led_config.off {
                        // LED is disabled
                        continue;
                    }

                    if let Some(teams_config) = &led_config.teams_state {
                        let is_state_active = meeting_state
                            .map(|state| Self::check_teams_state(state, &teams_config.teams_state))
                            .unwrap_or(false);

                        let color = if is_state_active {
                            teams_config.color_on.to_led_color()
                        } else {
                            teams_config.color_off.to_led_color()
                        };

                        if let Err(e) = device.send_command(SetLed::new(led_config.button_id, color)).await {
                            error!("Failed to set LED {}: {}", led_config.button_id, e);
                        }
                    }
                }
            }
        });
    }

    fn check_teams_state(state: &MeetingState, state_type: &TeamsStateType) -> bool {
        match state_type {
            TeamsStateType::IsMuted => state.is_muted,
            TeamsStateType::IsHandRaised => state.is_hand_raised,
            TeamsStateType::IsVideoOn => state.is_video_on,
            TeamsStateType::IsInMeeting => state.is_in_meeting,
            TeamsStateType::IsRecordingOn => state.is_recording_on,
            TeamsStateType::IsBackgroundBlurred => state.is_background_blurred,
            TeamsStateType::IsSharing => state.is_sharing,
            TeamsStateType::HasUnreadMessages => state.has_unread_messages,
        }
    }
}

async fn load_token(path: &PathBuf) -> String {
    match fs::read_to_string(path).await {
        Ok(token) => {
            info!("Loaded saved token from {:?}", path);
            token.trim().to_string()
        }
        Err(_) => {
            info!("No saved token found");
            String::new()
        }
    }
}

async fn save_token(path: &PathBuf, token: &str) -> Result<()> {
    fs::write(path, token)
        .await
        .with_context(|| format!("Failed to save token to {:?}", path))?;
    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    let args = Args::parse();

    // Initialize logging
    let log_level = if args.verbose { "debug" } else { "info" };
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or(log_level)).init();

    info!("Mutenix CLI v{}", env!("CARGO_PKG_VERSION"));

    // Create and run CLI
    let cli = MutenixCli::new(args).await?;
    cli.run().await?;

    Ok(())
}

